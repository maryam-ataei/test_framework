/*
 *****************************************************************************
 *  Automatically Generated search_module.c
 *  ----------------------------------------------------------------------------
 * This file was automatically generated by the `generate_module.py` script.
 * It extracts the `SEARCH_begin` to `SEARCH_end` module section
 * from the **source file**: `/home/maryam/FreeBSD/test_framework/cc_newreno_search.c` and was generated on 2025-05-01 14:41:48.
 *
 * This file is part of a test framework designed for evaluating TCP module implementations.
 *  
 *  ⚠ WARNING: 
 * If you modify this file directly, rerunning `generate_module.py` will overwrite your changes.
 *  
 *  ✅ To prevent losing your modifications:
 * - Modify the **source file** `/home/maryam/FreeBSD/test_framework/cc_newreno_search.c` instead.
 *****************************************************************************
*/

#include <string.h>
#include "cc.h"
#include "cc_newreno_search.h"
#include "cc_helper_function.h"

/* SEARCH */
 void search_reset(struct newreno* nreno, enum unset_bin_duration flag) {
	 memset(nreno->search_bin, 0, sizeof(nreno->search_bin));
	 nreno->search_curr_idx = -1;
	 nreno->search_bin_end_us = 0;
	 nreno->search_scale_factor = 0;
	 nreno->search_bytes_this_bin = 0;
	 if (flag == UNSET_BIN_DURATION_FALSE)
		 nreno->search_bin_duration_us = 0;
 }

 /////////////////// SEARCH ///////////////////////////////////
 uint64_t get_now_us(void) {
	 struct timeval tv;
	 getmicrouptime(&tv);  // Uptime since boot
	 return (tv.tv_sec * 1000000ULL) + tv.tv_usec;
 }
 
 uint64_t get_rtt_us(struct cc_var* ccv) {
	 uint64_t srtt = CCV(ccv, t_srtt);
	 return (((uint64_t)srtt) * tick) >> TCP_RTT_SHIFT;  // convert to microseconds
 }
 
 
 /* Scale bin value to fit bin size, rescale previous bins.
  * Return amount scaled.
  */
 uint8_t search_bit_shifting(struct cc_var* ccv, uint64_t bin_value) {
 
	 struct newreno* nreno = ccv->cc_data;
	 uint8_t num_shift = 0;	
	 uint8_t i = 0;
 
	 /* Adjust bin_value if it's greater than MAX_BIN_VALUE */
	 while (bin_value > MAX_US_INT) {
		 num_shift+= 1;
		 bin_value >>= 1;
	 }
 
	 /* Adjust all previous bins according to the new shift amount */
	 for (i = 0; i < SEARCH_TOTAL_BINS; i++) {
		 SEARCH_BIN(ccv, i) >>= num_shift;
	 }
 
	 /* Update the scale factor */
	 nreno->search_scale_factor += num_shift;
 
	 return num_shift;
 }
 
 /* Initialize bin */
 void search_init_bins(struct cc_var* ccv, uint64_t now_us, uint64_t rtt_us) {
 
	 struct newreno* nreno = ccv->cc_data;
 
	 uint8_t amount_scaled = 0;
	 uint64_t bin_value = 0;
 
	 if (nreno->search_bin_duration_us == 0)
		 nreno->search_bin_duration_us = (rtt_us * SEARCH_WINDOW_SIZE_FACTOR) / (SEARCH_BINS * 10);
	 nreno->search_bin_end_us = now_us + nreno->search_bin_duration_us;
	 nreno->search_curr_idx = 0;
 
	 bin_value = nreno->search_bytes_this_bin;
	 if (bin_value > MAX_US_INT) {
		 amount_scaled = search_bit_shifting(ccv, bin_value);
		 bin_value >>= amount_scaled;
	 }
 
	 nreno->search_bin[0] = (search_bin_t)bin_value;
	 nreno->search_bytes_this_bin = 0;
 
 }
 
 void search_update_bins(struct cc_var* ccv, uint64_t now_us, uint64_t rtt_us) {
 
	 struct newreno* nreno = ccv->cc_data;
 
	 uint32_t passed_bins = 0;
	 uint32_t i = 0;
	 uint64_t bin_value = 0;
	 uint8_t amount_scaled = 0; 
	 uint64_t initial_rtt = 0; 
	 uint64_t bin_value_before_reset = 0;
 
	 // Q: APP_limited?
	 /* FreeBSD doesn’t have an explicit app_limited field in the struct tcpcb, so we'll need to add and manage it. */
	
 
	 /* If passed_bins greater than 1, it means we have some missed bins */
	 passed_bins = ((now_us - nreno->search_bin_end_us) / nreno->search_bin_duration_us) + 1;
 
	 initial_rtt = nreno->search_bin_duration_us * SEARCH_BINS * 10 / SEARCH_WINDOW_SIZE_FACTOR;
 
	 /* Need reset due to missed bins*/
	 if (passed_bins > search_alpha * (initial_rtt / nreno->search_bin_duration_us)) {
 
		 /* Update bin_value before reset to fill the first bin after reset by whole acked bytes until this time*/
		 if (nreno->search_curr_idx == 0) 
			 bin_value_before_reset = nreno->search_bytes_this_bin + SEARCH_BIN(ccv, 0);
		 else
			 bin_value_before_reset = nreno->search_bytes_this_bin +SEARCH_BIN(ccv, nreno->search_curr_idx - 1);
 
		 if (passed_bins > SEARCH_BINS) 
			 search_reset(nreno, UNSET_BIN_DURATION_FALSE);
		 else 
			 search_reset(nreno, UNSET_BIN_DURATION_TRUE);
 
		 nreno->search_bytes_this_bin = bin_value_before_reset;
		 search_init_bins(ccv, now_us, rtt_us);
		 return;
	 }
 
	 for (i = nreno->search_curr_idx + 1; i < nreno->search_curr_idx + passed_bins; i++)
			 SEARCH_BIN(ccv, i) = SEARCH_BIN(ccv, nreno->search_curr_idx);
 
	 nreno->search_curr_idx += passed_bins;
	 nreno->search_bin_end_us += passed_bins * nreno->search_bin_duration_us;
 
	 /* Calculate bin_value by dividing bytes_acked by 2^scale_factor */
	 bin_value = (nreno->search_bytes_this_bin >> nreno->search_scale_factor);
 
	 if (nreno->search_curr_idx > 0) 
		 bin_value += SEARCH_BIN(ccv, nreno->search_curr_idx - 1);
 
 
	 if (bin_value > MAX_US_INT) {
		 amount_scaled =  search_bit_shifting(ccv, bin_value);
		 bin_value >>= amount_scaled;
	 }
 
	 // Assign bin value to current bin
	 SEARCH_BIN(ccv, nreno->search_curr_idx) = (search_bin_t)bin_value;
	 nreno->search_bytes_this_bin = 0;
 }
 
 /* Calculate delivered bytes for a window considering interpolation */
 uint64_t search_compute_delivered_window(struct cc_var* ccv, int32_t left, int32_t right, uint32_t fraction) {
 
	 uint64_t delivered = 0; 
 
	 delivered = SEARCH_BIN(ccv, right - 1) - SEARCH_BIN(ccv, left);
 
	 if (left == 0) { /* If we are interpolating using the very first bin, the "previous" bin value is 0. */
		 delivered += SEARCH_BIN(ccv, left) * fraction / 100;
	 } else {
		 delivered += (SEARCH_BIN(ccv, left) - SEARCH_BIN(ccv, left - 1)) * fraction / 100;
	 }
 
	 delivered += (SEARCH_BIN(ccv, right) - SEARCH_BIN(ccv, right - 1)) * (100 - fraction) / 100;
 
	 return delivered;
 }
 
 /* Handle slow start exit condition */
 void search_exit_slow_start(struct cc_var* ccv, uint64_t now_us, uint64_t rtt_us) {
	 struct newreno* nreno = ccv->cc_data;
 
	 int32_t cong_idx = 0;
	 uint32_t initial_rtt = 0;
	 uint64_t overshoot_bytes = 0;
	 uint32_t overshoot_cwnd = 0;
 
	 /*
	  * If cwnd rollback is enabled, the code calculates the initial round-trip time (RTT)
	  * and determines the congestion index (`cong_idx`) from which to compute the overshoot.
	  * The overshoot represents the excess bytes delivered beyond the estimated target,
	  * which is calculated over a window defined by the current and the rollback indices.
	  * 
	  * The rollback logic adjusts the congestion window (`snd_cwnd`) based on the overshoot:
	  * 1. It first computes the overshoot congestion window (`overshoot_cwnd`), derived by
	  *    dividing the overshoot bytes by the maximum segment size (MSS).
	  * 2. It reduces `snd_cwnd` by the calculated overshoot while ensuring it does not fall
	  *    below the initial congestion window (`TCP_INIT_CWND`), which acts as a safety guard.
	  * 3. If the overshoot exceeds the current congestion window, it resets `snd_cwnd` to the 
	  *    initial value, providing a safeguard to avoid a drastic drop in case of miscalculations
	  *    or unusual network conditions (e.g., TCP reset).
	  * 
	  * After adjusting the congestion window, the slow start threshold (`snd_ssthresh`) is set 
	  * to the updated congestion window to finalize the rollback.
	  */
 
	 if (V_cwnd_rollback) {
 
		 initial_rtt = nreno->search_bin_duration_us * SEARCH_BINS * 10 / SEARCH_WINDOW_SIZE_FACTOR;
		 cong_idx = nreno->search_curr_idx - ((2 * initial_rtt) / nreno->search_bin_duration_us);
 
		 /* Calculate the overshoot based on the delivered bytes between cong_idx and the current index */
		 overshoot_bytes = search_compute_delivered_window(ccv, cong_idx, nreno->search_curr_idx, 0);
 
		 /* Calculate the rollback congestion window based on overshoot divided by MSS */
		 overshoot_cwnd = overshoot_bytes / CCV(ccv, t_maxseg); //Q: mss is tcp_fixed_maxseg(ccv->ccvc.tcp) or CCV(ccv, t_maxseg)
		 /*
		  * Reduce the current congestion window,
		  * but guard so it doesn't drop below the initial cwnd
		  * or is not larger than the current cwnd (in case of TCP reset)
		  */
		 if (overshoot_cwnd < CCV(ccv, snd_cwnd))
			 CCV(ccv, snd_cwnd) = max(CCV(ccv, snd_cwnd) - overshoot_cwnd, V_tcp_initcwnd_segments);
		 else 
			 CCV(ccv, snd_cwnd) = V_tcp_initcwnd_segments;
	 }
 
	 CCV(ccv, snd_ssthresh) = CCV(ccv, snd_cwnd); 
 }
 
 void search_update(struct cc_var* ccv) {
 
	struct newreno* nreno = ccv->cc_data;
 
	uint64_t now_us = get_now_us();
	uint64_t rtt_us = get_rtt_us(ccv);

	int32_t prev_idx = 0;
	int64_t curr_delv_bytes = 0;	
	int64_t prev_delv_bytes = 0;	
	int32_t norm_diff = 0; 
	uint32_t fraction = 0;

	nreno->search_bytes_this_bin += ccv->bytes_this_ack;

	/* by receiving the first ack packet, initialize bin duration and bin end time */
	if (nreno->search_curr_idx < 0) {
		search_init_bins(ccv, now_us, rtt_us);
		return;
	}

	// Wait until reach the bin boundary,
	if (now_us < nreno->search_bin_end_us) {
		return;
	}
	
	search_update_bins(ccv, now_us, rtt_us);


	/* check if there is enough bins after shift for computing previous window */
	prev_idx = nreno->search_curr_idx - (rtt_us / nreno->search_bin_duration_us);

	if (prev_idx >= SEARCH_BINS && (nreno->search_curr_idx - prev_idx) < SEARCH_EXTRA_BINS - 1) {
		/* check if there is enough bins after shift for computing previous window */
		curr_delv_bytes = search_compute_delivered_window(ccv,
														nreno->search_curr_idx - SEARCH_BINS, 
														nreno->search_curr_idx, 
														0);

		fraction = ((rtt_us % nreno->search_bin_duration_us) * 100 / nreno -> search_bin_duration_us);

		prev_delv_bytes = search_compute_delivered_window(ccv, 
														prev_idx - SEARCH_BINS, 
														prev_idx, 
														fraction);

		if (prev_delv_bytes > 0) {
			norm_diff = ((2 * prev_delv_bytes) - curr_delv_bytes) * 100 / (2 * prev_delv_bytes);

			/* check for exit condition */
			if ((2 * prev_delv_bytes) >= curr_delv_bytes && norm_diff >= SEARCH_THRESH)
				search_exit_slow_start(ccv, now_us, rtt_us);
		}
	}
 
 }