# test_framework

This framework is designed to evaluate any TCP protocol by automating the generation of source and header files. Originally created for the SEARCH protocol, it has been generalized to work with any TCP protocol of your choice. It processes input data, applies the protocolâ€™s algorithm, and outputs the results.

## Key Features of the Framework:

- Automatically generates the necessary source and header files for any TCP protocol.

- Supports automatic handling of TCP protocol logic in the evaluation.

- Simplifies the testing and validation of custom TCP protocols without manual modifications.


## Files Overview
The test framework consists of the following files:

- generate_module.py: A Python script that automates the generation of the necessary source and header files by extracting protocol logic from an original source file.

- search_module.c: This file contains the protocol's implementation logic (e.g., SEARCH). It is generated by the generate_module.py script.

- search_defs.h: Contains function declarations and definitions related to the protocol. It is generated by the generate_module.py script.

- tcp.h: Defines mock structures (e.g., tcp_sock, sock) to simulate a kernel-like environment. This file is generated by the generate_module.py script.

- test_search.c: A C test file that reads input data, initializes mock structures, and runs the protocol's functions. This file is also generated by generate_module.py.

## How It Works

### Protocol Labeling

To enable automatic generation, you must label the relevant sections in your original code (protocol file). The labeling process for different sections is as follows:

#### Labeling for Protocol Logic (for search_module.c):

In the original protocol source code, you need to label the section containing the core protocol logic using comments.

protocol_name should be in upper case.

Example:
\
```c
// {protocol_name}_begin

  Code that implements the protocol logic
  
// {protocol_name}_end
```

#### Labeling for Definitions (for search_defs.h):

For function declarations and necessary definitions, label them in your original file as follows:

Example:
```c
// {protocol_name}_defs_begin

  Function declarations and other necessary definitions

// {protocol_name}_defs_end
```

For example for search:
```c
\\ SEARCH_begin
\\ SEARCH_end

\\ SEARCH_defs_begin
\\ SEARCH_defs_end
```



These labeled sections will be extracted and placed in the corresponding generated files.


## File Generation

Once you have labeled the relevant sections in your original protocol code, run the generate_module.py script to generate the necessary files:


`python generate_module.py <input_file> <keyword>`

<input_file>: The original source file for your TCP protocol (e.g., tcp_cubic_search.c).
<keyword>: A unique keyword to identify the protocol (e.g., search for the SEARCH protocol).

Example:

`python generate_module.py tcp_cubic_search.c search`

This will generate the following files:

- search_module.c (contains the core protocol logic)
- search_defs.h (contains function declarations)
- tcp.h (contains mock structures and definitions)
- search_test.c (test file that reads input data and runs the protocol's functions)

## Customization and Updating the Test

The framework can be used for any TCP protocol. After running the generate_module.py script, you need to modify the generated test_search.c file. The parts that need to be updated define by //NEED UPDATE: comment.

For example, if you're using the SEARCH protocol and the function is search_update, make sure to update test_search.c to include the following:

`search_update(sk_ptr, rtt_us);`

Make sure to call the desired function where it is needed.

## Running the Test
To run the test, use the following command:

`./search_test data_sample_viasat_fixed.csv > output.txt`

This command reads the input CSV file data_sample_viasat_fixed.csv, processes it using the protocol logic, and outputs the results to output.txt.

## Compilation

Once the files are generated, compile the framework using the provided Makefile. In the project directory, simply run:

`make`

This will automatically compile the search_test executable using the following command:

`gcc -o search_test search_module.c test_search.c -Wall -Wextra`

## Running the Test

To run the test, use the following command:

`./search_test data_sample_viasat_fixed.csv > output.txt`

## Input CSV Format
The CSV file should have the following columns in this order:

Column 1: now_us - The current timestamp in microseconds.

Column 2: bytes_acked - The number of bytes acknowledged.

Column 3: mss - The maximum segment size.

Column 4: rtt_us - The round-trip time in microseconds.

The first line of the CSV file will be skipped if it contains headers.

## Output
The output will display processed information, including the current bin index and the values for each bin.

## Cleanup
After the test finishes, the program will automatically free the allocated memory for the bictcp structure and close the input file.




