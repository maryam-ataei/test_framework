/*
 *****************************************************************************
 *  Automatically Generated bbr_test.c
 *  ----------------------------------------------------------------------------
 *  This file was automatically generated by `generate_module.py` on 2025-02-18 15:37:25.
 *  It is designed to test the `BBR` module using CSV input.
 *  This test file allows you to validate and verify your module.
 * 
 *  You can process CSV input, simulate various network conditions, and print relevant results.
 *  Modify this file to adjust parameters, conditions, or outputs for custom testing.
 *  
 *
 *  ⚠ WARNING: 
 *  If you modify this file directly, rerunning `generate_module.py` will overwrite your changes.
 *
 *  ✅ To prevent losing your modifications:
 *  - Modify `generate_module.py` to include your changes.
 *  - Set `GENERATE_TEST_FILE = 0` in `generate_module.py` to disable regeneration.
 *****************************************************************************
 */


#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include "tcp.h"
#include "bbr_defs.h"
#include "tcp_helper_function.h"

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <input.csv>\n", argv[0]);
        return 1;
    }

    // Open the CSV file
    FILE *file = fopen(argv[1], "r");
    if (!file) {
        perror("Failed to open file");
        return 1;
    }

    // Allocate memory for sock structure
    struct sock *sk = malloc(sizeof(struct sock));
    if (!sk) {
        fprintf(stderr, "Failed to allocate memory for sock.\n");
        fclose(file);
        return 1;
    }
    memset(sk, 0, sizeof(struct sock));  // Initialize struct to zero

    // Allocate memory for bbr inside sock
    sk->bbr = malloc(sizeof(struct bbr));
    if (!sk->bbr) {
        fprintf(stderr, "Failed to allocate memory for bbr.\n");
        free(sk);
        fclose(file);
        return 1;
    }

    struct tcp_sock *tp = tcp_sk(sk);
    struct bbr *bbr = inet_csk_ca(sk);

    // -----------------------------------------------------------------------------
    // ⚠ USER NOTE: Add your reset function below, if applicable.
    // Example: bictcp_search_reset(ca);
    // -----------------------------------------------------------------------------
    bbr_init(sk);            

    // Initialize protocol-specific variables
    tp->snd_ssthresh = TCP_INFINITE_SSTHRESH;
    tp->snd_cwnd = TCP_INIT_CWND;
    int EXIT_FLAG = 0;

    char line[256];
    int line_number = 0;

    printf("Processing CSV input: %s\n\n", argv[1]);

    while (fgets(line, sizeof(line), file)) {
        line_number++;

        // Skip the header line or lines that start with '#'
        if (line_number == 1 || line[0] == '#') {
            continue;
        }

        // Variables to store parsed values
        // -----------------------------------------------------------------------------
        // ⚠ USER NOTE: Define the variables based on your protocol's input,
        // parse the CSV value, and set parsed values to the mock structure.
        // -----------------------------------------------------------------------------
                    
        // Variables to store parsed values
        u32 now_us, bbr_full_bw, bbr_full_bw_cnt, bbr_max_bw, round_start, app_limited, bbr_min_rtt, bbr_state; 

        // Parse CSV line with ONLY the required variables
        if (sscanf(line, "%u,%u,%u,%u,%u,%u, %u, %u",
                   &now_us, &bbr_full_bw, &bbr_full_bw_cnt, &bbr_max_bw, &round_start, &app_limited, &bbr_min_rtt, &bbr_state) != 8) {
            fprintf(stderr, "Invalid line format at line %d: %s", line_number, line);
            continue;
        }

        // Set mock BBR state
        bbr->round_start = round_start;

        // Set bbr_max_bw directly from input
        minmax_reset(&bbr->bw, 0, bbr_max_bw);

        // Create a mock rate sample structure
        struct rate_sample rs;
        memset(&rs, 0, sizeof(rs));
        rs.is_app_limited = app_limited;

        // Call protocol-specific update functions
        // -----------------------------------------------------------------------------
        // ⚠ USER NOTE: Call the function(s) to start running your protocol.
        // -----------------------------------------------------------------------------     
        // Check if BBR has exited the STARTUP phase
        bbr_check_full_bw_reached(sk, &rs);


        // -----------------------------------------------------------------------------
        // ⚠ USER NOTE: Print results and info based on your requirements.
        // -----------------------------------------------------------------------------

        if (bbr_full_bw_reached(sk) && EXIT_FLAG == 0) {
            printf("BBR Exits STARTUP Phase at %u us\n", now_us);
            EXIT_FLAG = 1;
        }

        // Print details
        printf("Line %d:\n", line_number);
        printf("  now_us: %u\n", now_us);
        printf("  bbr_full_bw: %u\n", bbr->full_bw);
        printf("  bbr_max_bw: %u\n", bbr_max_bw);
        printf("  full_bw_cnt: %u\n", bbr->full_bw_cnt);
        printf("  round_start: %u\n", bbr->round_start);
        printf("  app_limited: %llu\n", rs.is_app_limited);
        printf("  full_bw_reached: %s\n", bbr_full_bw_reached(sk) ? "Yes" : "No");
        printf("  bbr_state: %u\n", bbr_state);
        printf("\n");
    }
    // Clean up memory
    if (sk->bbr) {
        free(sk->bbr);
    }
    free(sk);
    fclose(file);

    printf("Finished processing.\n");
    return 0;
}
